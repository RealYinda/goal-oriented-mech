//
// 文件名:     ElasFlow.C
// 软件包:     JAUMIN
// 版权　:     北京应用物理与计算数学研究所
// 版本号:     $Revision: 0 $
// 修改　:     $Date: Tue May 20 08:25:06 2014 $
// 描述　:     静力问题线弹性材料计算流程的实现.
// 类别　:     %Internal File% ( Don't delete this line )
//

#include "ElasFlow.h"
#include "PatchStrategy.h"
#ifdef DEBUG_CHECK_ASSERTIONS
#include <assert.h>
#endif

/*************************************************************************
 * 构造函数.
 *************************************************************************/
ElasFlow::ElasFlow(
    const string& object_name,
    tbox::Pointer<algs::StandardComponentPatchStrategy<NDIM> > strategy,
    tbox::Pointer<tbox::Database> input_db) {
#ifdef DEBUG_CHECK_ASSERTIONS
  assert(!object_name.empty());
  assert(strategy.getPointer() != NULL);
#endif

  d_patch_strategy = strategy;

  d_solver_db = input_db;
  d_solver_manager = solv::LinearSolverManager<NDIM>::getManager();
  d_solver = d_solver_manager->lookupLinearSolver(
      d_solver_db->getString("solver_name"));
  d_object_name = object_name;
  t_fem_build_matrix =
      tbox::TimerManager::getManager()->getTimer("ELAS::FEM::buildMatrix");
  t_fem_solve =
      tbox::TimerManager::getManager()->getTimer("ELAS::Solver::TOTAL");
  t_fem_post = tbox::TimerManager::getManager()->getTimer("ELAS::FEM::POST");
}

/*************************************************************************
 * 析构函数.
 ************************************************************************/
ElasFlow::~ElasFlow() {}

/*************************************************************************
 * 初始化网格层积分算法: 创建所有计算需要的积分构件.
 *
 * 该函数创建了8个构件. 这些构件所操作的数据片,
 * 由函数 d_patch_strategy->initializeComponent() 指定.
 *
 *************************************************************************/
void ElasFlow::initializeLevelIntegrator(
    tbox::Pointer<algs::IntegratorComponentManager<NDIM> > manager) {
  /// 初始化构件.
  d_init_intc = new algs::InitializeIntegratorComponent<NDIM>(
      "INIT", d_patch_strategy, manager);
  // 数值构件: 更新结点坐标.
  d_num_intc_displacement = new algs::NumericalIntegratorComponent<NDIM>(
      "DISPLACEMENT", d_patch_strategy, manager);
  // 数值构件: 计算应力.
  d_num_intc_stress = new algs::NumericalIntegratorComponent<NDIM>(
      "STRESS", d_patch_strategy, manager);
  // 数值构件: 计算矩阵.
  d_num_intc_mat = new algs::NumericalIntegratorComponent<NDIM>(
      "MAT", d_patch_strategy, manager);
  // 数值构件: 计算右端项.
  d_num_intc_rhs = new algs::NumericalIntegratorComponent<NDIM>(
      "RHS", d_patch_strategy, manager);
  // 数值构件: 计算载荷.
  d_num_intc_load = new algs::NumericalIntegratorComponent<NDIM>(
      "LOAD", d_patch_strategy, manager);
  // 数值构件: 计算约束.
  d_num_intc_cons = new algs::NumericalIntegratorComponent<NDIM>(
      "CONS", d_patch_strategy, manager);
  d_alloc_data = new algs::MemoryIntegratorComponent<NDIM>(
      "ALLOC", d_patch_strategy, manager);
}

/*************************************************************************
 *  初始化网格层上的数据.
 ************************************************************************/
void ElasFlow::initializeLevelData(
    const tbox::Pointer<hier::BasePatchLevel<NDIM> > level,
    const double init_data_time, const bool initial_time) {
  /// 初始化网格层上的数据.
  d_init_intc->initializeLevelData(level, init_data_time, initial_time);
}

/*************************************************************************
 * 向前积分一个时间步.
 *
 * 注解: 该函数调用构件，计算矩阵右端项, 设置边界条件, 并求解线性系统.
 * 调用数值构件计算应力,更新结点坐标.
 *
 ************************************************************************/
int ElasFlow::advanceLevel(
    const tbox::Pointer<hier::BasePatchLevel<NDIM> > level,
    const double current_time, const double predict_dt, const double max_dt,
    const double min_dt, const bool first_step, const int step_number,
    double& actual_dt) {
#ifdef DEBUG_CHECK_ASSERTIONS
  assert(!level.isNull());
#endif
  const tbox::Pointer<hier::PatchLevel<NDIM> > patch_level = level;

  actual_dt = predict_dt;

  /// 为矩阵向量开辟内存
  d_alloc_data->allocatePatchData(patch_level, current_time + predict_dt);

  t_fem_build_matrix->start();
  /// 调用数值构件接口函数,计算并组装矩阵
  d_num_intc_mat->computing(patch_level, current_time, actual_dt);

  /// 调用数值构件接口函数,计算并组装右端项
  d_num_intc_rhs->computing(patch_level, current_time, actual_dt);

  /// 调用数值构件接口函数,加载载荷
  d_num_intc_load->computing(patch_level, current_time, actual_dt);

  /// 调用数值构件接口函数,加载约束
  d_num_intc_cons->computing(patch_level, current_time, actual_dt);
  t_fem_build_matrix->stop();

  /// 获取参数
  tbox::Pointer<PatchStrategy> p_strategy = d_patch_strategy;
  int mat_id = p_strategy->getMatrixID();
  int vec_id = p_strategy->getRHSID();
  int sol_id = p_strategy->getSolutionID();

  /// 设置解法器
  d_solver->setMatrix(mat_id);
  d_solver->setRHS(vec_id);
  t_fem_solve->start();
  /// 求解
  d_solver->solve(first_step, sol_id, patch_level, d_solver_db);
  t_fem_solve->stop();

  t_fem_post->start();
  /// 调用数值构件接口函数, 根据位移更新结点坐标.
  d_num_intc_displacement->computing(patch_level, current_time, actual_dt,
                                     false);

  /// 调用数值构件接口函数, 计算应力.
  d_num_intc_stress->computing(patch_level, current_time, actual_dt, false);
  t_fem_post->stop();

  actual_dt = predict_dt;
  d_alloc_data->deallocatePatchData(patch_level);

  return (0);
}
